import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { findWords } from '../../../resources/api';

const initialState = {
  status: 'idle',
  words: [],
  isError: false,
  error: '',
};

export const searchForWords = createAsyncThunk(
  'keypad/findWords',
  async ({ inputNumber, useDictionary }, dispatch) => {
    const result = await findWords(inputNumber, useDictionary);
    return result;
  }
);

export const keypadSlice = createSlice({
  name: 'keypad',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    // Redux Toolkit allows us to write "mutating" logic in reducers. It
    // doesn't actually mutate the state because it uses the Immer library,
    // which detects changes to a "draft state" and produces a brand new
    // immutable state based off those changes
    clearWords: (state) => {
      state.words = [];
    },
    setWordsResult: (state, action) => {
      state.words = action.payload;
    },
  },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(searchForWords.pending, (state) => {
        state.status = 'loading';
        state.isError = false;
      })
      .addCase(searchForWords.fulfilled, (state, action) => {
        state.status = 'idle';
        state.words = action.payload;
      })
      .addCase(searchForWords.rejected, (state, action) => {
        state.status = 'error';
        state.isError = true;
        state.error = action.error.message;
      });
  },

});

export const { clearWords, setWordsResult } = keypadSlice.actions;

export const selectWords = (state) => state.keypad.words;
export const selectIsError = (state) => state.keypad.isError;
export const selectErrorMsg = (state) => state.keypad.error;

export default keypadSlice.reducer;
